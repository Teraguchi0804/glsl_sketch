{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap d81f9b2b1b97c0a0e6a6","webpack:///./src/js/app.js","webpack:///./src/js/main.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","checkChange","e","run","currentTarget","checked","startTime","Date","getTime","render","tempTime","time","mouseMove","mx","offsetX","cw","my","offsetY","ch","gl","clear","COLOR_BUFFER_BIT","uniform1f","uniLocation","uniform2fv","drawElements","TRIANGLES","UNSIGNED_SHORT","flush","setTimeout","fps","create_shader","shader","scriptElement","document","getElementById","type","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","text","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","console","log","create_program","vs","fs","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","create_vbo","data","vbo","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","create_ibo","ibo","ELEMENT_ARRAY_BUFFER","Int16Array","eCheck","Array","window","onload","width","height","addEventListener","getContext","prg","getUniformLocation","position","index","vPosition","vIndex","vAttLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","clearColor"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GE5CrBA,EAAQ,IFoDb,SAASI,EAAQD,GGkCvB,QAASQ,GAAYC,GACpBC,EAAMD,EAAEE,cAAcC,QAClBF,GACHG,GAAY,GAAIC,OAAOC,UACvBC,KAEAC,GAAYC,EAKd,QAASC,GAAUV,GAClBW,EAAKX,EAAEY,QAAUC,EACjBC,EAAKd,EAAEe,QAAUC,EAIlB,QAAST,KAEHN,IAKLQ,EAA4C,OAApC,GAAIJ,OAAOC,UAAYF,GAG/Ba,EAAGC,MAAMD,EAAGE,kBAGZF,EAAGG,UAAUC,EAAY,GAAIZ,EAAOD,GACpCS,EAAGK,WAAWD,EAAY,IAAKV,EAAIG,IACnCG,EAAGK,WAAWD,EAAY,IAAKR,EAAIG,IAGnCC,EAAGM,aAAaN,EAAGO,UAAW,EAAGP,EAAGQ,eAAgB,GACpDR,EAAGS,QAGHC,WAAWpB,EAAQqB,IAIpB,QAASC,GAAcpC,GAEtB,GAAIqC,GAGAC,EAAgBC,SAASC,eAAexC,EAG5C,IAAKsC,EAAL,CAKA,OAAQA,EAAcG,MAGrB,IAAK,oBACJJ,EAASb,EAAGkB,aAAalB,EAAGmB,cAC5B,MAGD,KAAK,sBACJN,EAASb,EAAGkB,aAAalB,EAAGoB,gBAC5B,MACD,SACC,OAUF,MANApB,GAAGqB,aAAaR,EAAQC,EAAcQ,MAGtCtB,EAAGuB,cAAcV,GAGbb,EAAGwB,mBAAmBX,EAAQb,EAAGyB,gBAG7BZ,GAIPa,MAAM1B,EAAG2B,iBAAiBd,QAC1Be,SAAQC,IAAI7B,EAAG2B,iBAAiBd,MAKlC,QAASiB,GAAeC,EAAIC,GAE3B,GAAIC,GAAUjC,EAAGkC,eAUjB,OAPAlC,GAAGmC,aAAaF,EAASF,GACzB/B,EAAGmC,aAAaF,EAASD,GAGzBhC,EAAGoC,YAAYH,GAGXjC,EAAGqC,oBAAoBJ,EAASjC,EAAGsC,cAGtCtC,EAAGuC,WAAWN,GAGPA,GAIA,KAKT,QAASO,GAAWC,GAEnB,GAAIC,GAAM1C,EAAG2C,cAYb,OATA3C,GAAG4C,WAAW5C,EAAG6C,aAAcH,GAG/B1C,EAAG8C,WAAW9C,EAAG6C,aAAc,GAAIE,cAAaN,GAAOzC,EAAGgD,aAG1DhD,EAAG4C,WAAW5C,EAAG6C,aAAc,MAGxBH,EAIR,QAASO,GAAWR,GAEnB,GAAIS,GAAMlD,EAAG2C,cAYb,OATA3C,GAAG4C,WAAW5C,EAAGmD,qBAAsBD,GAGvClD,EAAG8C,WAAW9C,EAAGmD,qBAAsB,GAAIC,YAAWX,GAAOzC,EAAGgD,aAGhEhD,EAAG4C,WAAW5C,EAAGmD,qBAAsB,MAGhCD,EA1NR,GAAItE,GAAGgB,EAAIG,EAAIL,EAAIG,EAAIG,EAAIhB,EAAKqE,EAC5BlE,EACAK,EAAO,EACPD,EAAW,EACXoB,EAAM,IAAO,GACbP,EAAc,GAAIkD,MAGtBC,QAAOC,OAAS,WAEf5E,EAAImC,SAASC,eAAe,UAG5BpB,EAAK,IACLG,EAAK,IACLnB,EAAE6E,MAAQ7D,EACVhB,EAAE8E,OAAS3D,EAGXsD,EAAStC,SAASC,eAAe,SAGjCpC,EAAE+E,iBAAiB,YAAalE,GAAW,GAC3C4D,EAAOM,iBAAiB,SAAU7E,GAAa,GAG/CkB,EAAKpB,EAAEgF,WAAW,UAAYhF,EAAEgF,WAAW,qBAG3C,IAAIC,GAAM/B,EAAelB,EAAc,MAAOA,EAAc,MAC5D5B,GAAc,MAAP6E,EACF7E,IACJqE,EAAOnE,SAAU,GAElBkB,EAAY,GAAKJ,EAAG8D,mBAAmBD,EAAK,QAC5CzD,EAAY,GAAKJ,EAAG8D,mBAAmBD,EAAK,SAC5CzD,EAAY,GAAKJ,EAAG8D,mBAAmBD,EAAK,aAG5C,IAAIE,KACH,EAAM,EAAK,EACX,EAAK,EAAK,GACV,GAAM,EAAM,EACZ,GAAK,EAAM,GAERC,GACH,EAAG,EAAG,EACN,EAAG,EAAG,GAEHC,EAAYzB,EAAWuB,GACvBG,EAASjB,EAAWe,GACpBG,EAAenE,EAAGoE,kBAAkBP,EAAK,WAC7C7D,GAAG4C,WAAW5C,EAAG6C,aAAcoB,GAC/BjE,EAAGqE,wBAAwBF,GAC3BnE,EAAGsE,oBAAoBH,EAAc,EAAGnE,EAAGuE,OAAO,EAAO,EAAG,GAC5DvE,EAAG4C,WAAW5C,EAAGmD,qBAAsBe,GAGvClE,EAAGwE,WAAW,EAAK,EAAK,EAAK,GAC7B9E,EAAK,GACLG,EAAK,GACLV,GAAY,GAAIC,OAAOC,UAGvBC","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\t\n\t// console.log(cats);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// sample_068\n\t//\n\t// GLSL だけでレンダリングする\n\t\n\t// GLSL サンプルの(ほぼ)共通仕様 =============================================\n\t//\n\t// ・シェーダのコンパイルに失敗した場合は auto run を無効にします\n\t// ・auto run は 30fps になっているので環境と負荷に応じて適宜変更しましょう\n\t// ・uniform 変数は以下のようにシェーダへ送られます\n\t//     ・time: 経過時間を秒単位(ミリ秒は小数点以下)で送る(float)\n\t//     ・mouse: マウス座標を canvas 左上原点で 0 ～ 1 の範囲で送る(vec2)\n\t//     ・resolution: スクリーンの縦横の幅をピクセル単位で送る(vec2)\n\t// ・シェーダのコンパイルに失敗した場合エラー内容をアラートとコンソールに出力\n\t// ・シェーダのエラーで表示される行番号は一致するように HTML を書いてあります\n\t//\n\t// ============================================================================\n\t\n\t// global\n\tvar c, cw, ch, mx, my, gl, run, eCheck;\n\tvar startTime;\n\tvar time = 0.0;\n\tvar tempTime = 0.0;\n\tvar fps = 1000 / 30;\n\tvar uniLocation = new Array();\n\t\n\t// onload\n\twindow.onload = function () {\n\t\t// canvas エレメントを取得\n\t\tc = document.getElementById('canvas');\n\t\n\t\t// canvas サイズ\n\t\tcw = 512;\n\t\tch = 512;\n\t\tc.width = cw;\n\t\tc.height = ch;\n\t\n\t\t// エレメントを取得\n\t\teCheck = document.getElementById('check');\n\t\n\t\t// イベントリスナー登録\n\t\tc.addEventListener('mousemove', mouseMove, true);\n\t\teCheck.addEventListener('change', checkChange, true);\n\t\n\t\t// WebGL コンテキストを取得\n\t\tgl = c.getContext('webgl') || c.getContext('experimental-webgl');\n\t\n\t\t// シェーダ周りの初期化\n\t\tvar prg = create_program(create_shader('vs'), create_shader('fs'));\n\t\trun = prg != null;\n\t\tif (!run) {\n\t\t\teCheck.checked = false;\n\t\t}\n\t\tuniLocation[0] = gl.getUniformLocation(prg, 'time');\n\t\tuniLocation[1] = gl.getUniformLocation(prg, 'mouse');\n\t\tuniLocation[2] = gl.getUniformLocation(prg, 'resolution');\n\t\n\t\t// 頂点データ回りの初期化\n\t\tvar position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];\n\t\tvar index = [0, 2, 1, 1, 2, 3];\n\t\tvar vPosition = create_vbo(position);\n\t\tvar vIndex = create_ibo(index);\n\t\tvar vAttLocation = gl.getAttribLocation(prg, 'position');\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vPosition);\n\t\tgl.enableVertexAttribArray(vAttLocation);\n\t\tgl.vertexAttribPointer(vAttLocation, 3, gl.FLOAT, false, 0, 0);\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex);\n\t\n\t\t// その他の初期化\n\t\tgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\t\tmx = 0.5;\n\t\tmy = 0.5;\n\t\tstartTime = new Date().getTime();\n\t\n\t\t// レンダリング関数呼出\n\t\trender();\n\t};\n\t\n\t// checkbox\n\tfunction checkChange(e) {\n\t\trun = e.currentTarget.checked;\n\t\tif (run) {\n\t\t\tstartTime = new Date().getTime();\n\t\t\trender();\n\t\t} else {\n\t\t\ttempTime += time;\n\t\t}\n\t}\n\t\n\t// mouse\n\tfunction mouseMove(e) {\n\t\tmx = e.offsetX / cw;\n\t\tmy = e.offsetY / ch;\n\t}\n\t\n\t// レンダリングを行う関数\n\tfunction render() {\n\t\t// フラグチェック\n\t\tif (!run) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// 時間管理\n\t\ttime = (new Date().getTime() - startTime) * 0.001;\n\t\n\t\t// カラーバッファをクリア\n\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\n\t\t// uniform 関連\n\t\tgl.uniform1f(uniLocation[0], time + tempTime);\n\t\tgl.uniform2fv(uniLocation[1], [mx, my]);\n\t\tgl.uniform2fv(uniLocation[2], [cw, ch]);\n\t\n\t\t// 描画\n\t\tgl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n\t\tgl.flush();\n\t\n\t\t// 再帰\n\t\tsetTimeout(render, fps);\n\t}\n\t\n\t// シェーダを生成する関数\n\tfunction create_shader(id) {\n\t\t// シェーダを格納する変数\n\t\tvar shader;\n\t\n\t\t// HTMLからscriptタグへの参照を取得\n\t\tvar scriptElement = document.getElementById(id);\n\t\n\t\t// scriptタグが存在しない場合は抜ける\n\t\tif (!scriptElement) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// scriptタグのtype属性をチェック\n\t\tswitch (scriptElement.type) {\n\t\n\t\t\t// 頂点シェーダの場合\n\t\t\tcase 'x-shader/x-vertex':\n\t\t\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t\t\t\tbreak;\n\t\n\t\t\t// フラグメントシェーダの場合\n\t\t\tcase 'x-shader/x-fragment':\n\t\t\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t\n\t\t// 生成されたシェーダにソースを割り当てる\n\t\tgl.shaderSource(shader, scriptElement.text);\n\t\n\t\t// シェーダをコンパイルする\n\t\tgl.compileShader(shader);\n\t\n\t\t// シェーダが正しくコンパイルされたかチェック\n\t\tif (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\n\t\t\t// 成功していたらシェーダを返して終了\n\t\t\treturn shader;\n\t\t} else {\n\t\n\t\t\t// 失敗していたらエラーログをアラートしコンソールに出力\n\t\t\talert(gl.getShaderInfoLog(shader));\n\t\t\tconsole.log(gl.getShaderInfoLog(shader));\n\t\t}\n\t}\n\t\n\t// プログラムオブジェクトを生成しシェーダをリンクする関数\n\tfunction create_program(vs, fs) {\n\t\t// プログラムオブジェクトの生成\n\t\tvar program = gl.createProgram();\n\t\n\t\t// プログラムオブジェクトにシェーダを割り当てる\n\t\tgl.attachShader(program, vs);\n\t\tgl.attachShader(program, fs);\n\t\n\t\t// シェーダをリンク\n\t\tgl.linkProgram(program);\n\t\n\t\t// シェーダのリンクが正しく行なわれたかチェック\n\t\tif (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\n\t\t\t// 成功していたらプログラムオブジェクトを有効にする\n\t\t\tgl.useProgram(program);\n\t\n\t\t\t// プログラムオブジェクトを返して終了\n\t\t\treturn program;\n\t\t} else {\n\t\n\t\t\t// 失敗していたら NULL を返す\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t// VBOを生成する関数\n\tfunction create_vbo(data) {\n\t\t// バッファオブジェクトの生成\n\t\tvar vbo = gl.createBuffer();\n\t\n\t\t// バッファをバインドする\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\t\n\t\t// バッファにデータをセット\n\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n\t\n\t\t// バッファのバインドを無効化\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t\n\t\t// 生成した VBO を返して終了\n\t\treturn vbo;\n\t}\n\t\n\t// IBOを生成する関数\n\tfunction create_ibo(data) {\n\t\t// バッファオブジェクトの生成\n\t\tvar ibo = gl.createBuffer();\n\t\n\t\t// バッファをバインドする\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n\t\n\t\t// バッファにデータをセット\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);\n\t\n\t\t// バッファのバインドを無効化\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\t\n\t\t// 生成したIBOを返して終了\n\t\treturn ibo;\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d81f9b2b1b97c0a0e6a6","var cats = require('./main.js');\n\n// console.log(cats);\n\n\n// WEBPACK FOOTER //\n// ./src/js/app.js","// sample_068\n//\n// GLSL だけでレンダリングする\n\n// GLSL サンプルの(ほぼ)共通仕様 =============================================\n//\n// ・シェーダのコンパイルに失敗した場合は auto run を無効にします\n// ・auto run は 30fps になっているので環境と負荷に応じて適宜変更しましょう\n// ・uniform 変数は以下のようにシェーダへ送られます\n//     ・time: 経過時間を秒単位(ミリ秒は小数点以下)で送る(float)\n//     ・mouse: マウス座標を canvas 左上原点で 0 ～ 1 の範囲で送る(vec2)\n//     ・resolution: スクリーンの縦横の幅をピクセル単位で送る(vec2)\n// ・シェーダのコンパイルに失敗した場合エラー内容をアラートとコンソールに出力\n// ・シェーダのエラーで表示される行番号は一致するように HTML を書いてあります\n//\n// ============================================================================\n\n// global\nvar c, cw, ch, mx, my, gl, run, eCheck;\nvar startTime;\nvar time = 0.0;\nvar tempTime = 0.0;\nvar fps = 1000 / 30;\nvar uniLocation = new Array();\n\n// onload\nwindow.onload = function () {\n\t// canvas エレメントを取得\n\tc = document.getElementById('canvas');\n\n\t// canvas サイズ\n\tcw = 512;\n\tch = 512;\n\tc.width = cw;\n\tc.height = ch;\n\n\t// エレメントを取得\n\teCheck = document.getElementById('check');\n\n\t// イベントリスナー登録\n\tc.addEventListener('mousemove', mouseMove, true);\n\teCheck.addEventListener('change', checkChange, true);\n\n\t// WebGL コンテキストを取得\n\tgl = c.getContext('webgl') || c.getContext('experimental-webgl');\n\n\t// シェーダ周りの初期化\n\tvar prg = create_program(create_shader('vs'), create_shader('fs'));\n\trun = (prg != null);\n\tif (!run) {\n\t\teCheck.checked = false;\n\t}\n\tuniLocation[0] = gl.getUniformLocation(prg, 'time');\n\tuniLocation[1] = gl.getUniformLocation(prg, 'mouse');\n\tuniLocation[2] = gl.getUniformLocation(prg, 'resolution');\n\n\t// 頂点データ回りの初期化\n\tvar position = [\n\t\t-1.0, 1.0, 0.0,\n\t\t1.0, 1.0, 0.0,\n\t\t-1.0, -1.0, 0.0,\n\t\t1.0, -1.0, 0.0\n\t];\n\tvar index = [\n\t\t0, 2, 1,\n\t\t1, 2, 3\n\t];\n\tvar vPosition = create_vbo(position);\n\tvar vIndex = create_ibo(index);\n\tvar vAttLocation = gl.getAttribLocation(prg, 'position');\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vPosition);\n\tgl.enableVertexAttribArray(vAttLocation);\n\tgl.vertexAttribPointer(vAttLocation, 3, gl.FLOAT, false, 0, 0);\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex);\n\n\t// その他の初期化\n\tgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\tmx = 0.5;\n\tmy = 0.5;\n\tstartTime = new Date().getTime();\n\n\t// レンダリング関数呼出\n\trender();\n};\n\n// checkbox\nfunction checkChange(e) {\n\trun = e.currentTarget.checked;\n\tif (run) {\n\t\tstartTime = new Date().getTime();\n\t\trender();\n\t} else {\n\t\ttempTime += time;\n\t}\n}\n\n// mouse\nfunction mouseMove(e) {\n\tmx = e.offsetX / cw;\n\tmy = e.offsetY / ch;\n}\n\n// レンダリングを行う関数\nfunction render() {\n\t// フラグチェック\n\tif (!run) {\n\t\treturn;\n\t}\n\n\t// 時間管理\n\ttime = (new Date().getTime() - startTime) * 0.001;\n\n\t// カラーバッファをクリア\n\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\t// uniform 関連\n\tgl.uniform1f(uniLocation[0], time + tempTime);\n\tgl.uniform2fv(uniLocation[1], [mx, my]);\n\tgl.uniform2fv(uniLocation[2], [cw, ch]);\n\n\t// 描画\n\tgl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n\tgl.flush();\n\n\t// 再帰\n\tsetTimeout(render, fps);\n}\n\n// シェーダを生成する関数\nfunction create_shader(id) {\n\t// シェーダを格納する変数\n\tvar shader;\n\n\t// HTMLからscriptタグへの参照を取得\n\tvar scriptElement = document.getElementById(id);\n\n\t// scriptタグが存在しない場合は抜ける\n\tif (!scriptElement) {\n\t\treturn;\n\t}\n\n\t// scriptタグのtype属性をチェック\n\tswitch (scriptElement.type) {\n\n\t\t// 頂点シェーダの場合\n\t\tcase 'x-shader/x-vertex':\n\t\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t\t\tbreak;\n\n\t\t// フラグメントシェーダの場合\n\t\tcase 'x-shader/x-fragment':\n\t\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\treturn;\n\t}\n\n\t// 生成されたシェーダにソースを割り当てる\n\tgl.shaderSource(shader, scriptElement.text);\n\n\t// シェーダをコンパイルする\n\tgl.compileShader(shader);\n\n\t// シェーダが正しくコンパイルされたかチェック\n\tif (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\n\t\t// 成功していたらシェーダを返して終了\n\t\treturn shader;\n\t} else {\n\n\t\t// 失敗していたらエラーログをアラートしコンソールに出力\n\t\talert(gl.getShaderInfoLog(shader));\n\t\tconsole.log(gl.getShaderInfoLog(shader));\n\t}\n}\n\n// プログラムオブジェクトを生成しシェーダをリンクする関数\nfunction create_program(vs, fs) {\n\t// プログラムオブジェクトの生成\n\tvar program = gl.createProgram();\n\n\t// プログラムオブジェクトにシェーダを割り当てる\n\tgl.attachShader(program, vs);\n\tgl.attachShader(program, fs);\n\n\t// シェーダをリンク\n\tgl.linkProgram(program);\n\n\t// シェーダのリンクが正しく行なわれたかチェック\n\tif (gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\n\t\t// 成功していたらプログラムオブジェクトを有効にする\n\t\tgl.useProgram(program);\n\n\t\t// プログラムオブジェクトを返して終了\n\t\treturn program;\n\t} else {\n\n\t\t// 失敗していたら NULL を返す\n\t\treturn null;\n\t}\n}\n\n// VBOを生成する関数\nfunction create_vbo(data) {\n\t// バッファオブジェクトの生成\n\tvar vbo = gl.createBuffer();\n\n\t// バッファをバインドする\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\n\t// バッファにデータをセット\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n\n\t// バッファのバインドを無効化\n\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t// 生成した VBO を返して終了\n\treturn vbo;\n}\n\n// IBOを生成する関数\nfunction create_ibo(data) {\n\t// バッファオブジェクトの生成\n\tvar ibo = gl.createBuffer();\n\n\t// バッファをバインドする\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n\n\t// バッファにデータをセット\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);\n\n\t// バッファのバインドを無効化\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n\t// 生成したIBOを返して終了\n\treturn ibo;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js"],"sourceRoot":""}